import streamlit as st
import pandas as pd
import matplotlib.pyplot as plt
from datetime import datetime, date, timedelta
import numpy as np
from fpdf import FPDF
from io import BytesIO
import json
import os
import hashlib
from data.base import st_style, head
from supabase_client import supabase
from openai import OpenAI
from dotenv import load_dotenv
from app.diet_tracker import load_meal_log, get_user_filename as get_meal_filename
from app.history import get_user_by_email

# Timezone import for IST
try:
    from zoneinfo import ZoneInfo
    IST = ZoneInfo("Asia/Kolkata")
except ImportError:
    from pytz import timezone
    IST = timezone("Asia/Kolkata")

# Load environment variables
load_dotenv()
client = OpenAI(api_key=os.getenv("OPENAI_API_KEY"))

def get_user_sugar_filename(user_email):
    """Generate a safe filename for user's sugar log based on email."""
    email_hash = hashlib.md5(user_email.encode()).hexdigest()[:12]
    return f"sugar_log_{email_hash}.json"

def save_sugar_log(sugar_log, user_email):
    """Save sugar log to a JSON file for persistence."""
    filename = get_user_sugar_filename(user_email)
    try:
        os.makedirs("user_data", exist_ok=True)
        filepath = os.path.join("user_data", filename)
        with open(filepath, "w") as f:
            serializable_log = []
            for entry in sugar_log:
                entry_copy = entry.copy()
                if isinstance(entry_copy['timestamp'], datetime):
                    entry_copy['timestamp'] = entry_copy['timestamp'].isoformat()
                serializable_log.append(entry_copy)
            json.dump(serializable_log, f)
    except Exception as e:
        st.error(f"Failed to save sugar log: {e}")

def load_sugar_log(user_email):
    """Load sugar log from a JSON file."""
    filename = get_user_sugar_filename(user_email)
    filepath = os.path.join("user_data", filename)
    try:
        if os.path.exists(filepath):
            with open(filepath, "r") as f:
                data = json.load(f)
                for entry in data:
                    if isinstance(entry['timestamp'], str):
                        try:
                            entry['timestamp'] = datetime.fromisoformat(entry['timestamp'])
                        except ValueError:
                            entry['timestamp'] = pd.to_datetime(entry['timestamp'])
                return data
        return []
    except Exception as e:
        st.error(f"Failed to load sugar log: {e}")
        return []

def get_ai_recommendations(sugar_data, meal_data, user_profile, history_data):
    """Generate recommendations based on sugar levels, meals, profile, and history."""
    try:
        if not sugar_data:
            return "Please log some sugar level readings to get personalized recommendations."

        # Sugar level summary (last 7 days)
        last_7_days = [entry for entry in sugar_data if (datetime.now(IST) - entry['timestamp']).days <= 7]
        if not last_7_days:
            return "No recent sugar readings. Log more data for recommendations."
        avg_sugar = np.mean([entry['sugar_level'] for entry in last_7_days])
        max_sugar = max([entry['sugar_level'] for entry in last_7_days])
        min_sugar = min([entry['sugar_level'] for entry in last_7_days])
        latest_sugar = sugar_data[-1]['sugar_level']

        # Meal summary (last 24 hours)
        last_24_hours = [meal for meal in meal_data if (datetime.now(IST) - meal['timestamp']).total_seconds() <= 24*3600]
        meal_summary = f"Meals in last 24 hours: {', '.join([f"{m['food']} ({m['calories']} kcal)" for m in last_24_hours]) or 'None'}"
        total_carbs = sum(m['carbs'] for m in last_24_hours) if last_24_hours else 0

        # User profile
        age = user_profile.get('age', 'unknown')
        weight = user_profile.get('weight', 'unknown')
        height = user_profile.get('height', 'unknown')
        bmi = weight / ((height / 100) ** 2) if isinstance(weight, (int, float)) and isinstance(height, (int, float)) and height > 0 else 'unknown'

        # History summary
        glucose_history = [h['glucose'] for h in history_data[-5:]] if history_data else []
        avg_glucose_history = np.mean(glucose_history) if glucose_history else 'unknown'
        risk_percent = history_data[-1]['risk_percent'] if history_data else 'unknown'

        prompt = f"""Provide medical guidance for diabetes management based on the following data. Do not mention AI or any model.

        Patient Data:
        - Age: {age} years
        - BMI: {bmi:.1f} (if known)
        - Recent meals (24 hours): {meal_summary}
        - Total carbohydrates (24 hours): {total_carbs:.1f}g

        Blood Sugar Data (last 7 days):
        - Latest reading: {latest_sugar} mg/dL
        - Average: {avg_sugar:.1f} mg/dL
        - Highest: {max_sugar} mg/dL
        - Lowest: {min_sugar} mg/dL

        Prediction History (last 5 entries):
        - Average glucose: {avg_glucose_history:.1f} mg/dL (if known)
        - Latest risk percent: {risk_percent}% (if known)

        Provide:
        1. Brief assessment of current sugar levels
        2. 3-4 specific dietary recommendations considering recent meals
        3. 2-3 preventive measures for diabetes control
        4. 2-3 lifestyle suggestions for long-term health

        Keep the response concise, actionable, and focused on diabetes management."""
        
        response = client.chat.completions.create(
            model="gpt-4o-mini",
            store=True,
            messages=[{"role": "user", "content": prompt}],
            max_tokens=300,
            temperature=0.7
        )
        return response.choices[0].message.content.strip()
    except Exception as e:
        st.error(f"Error generating recommendations: {str(e)}")
        return "Unable to generate recommendations at this time. Consult your healthcare provider."

def generate_pdf_report(sugar_log, recommendations, user_email):
    pdf = FPDF()
    pdf.add_page()
    pdf.set_font("Arial", size=14)
    pdf.cell(0, 10, "Sugar Tracker Daily Report", ln=True, align="C")
    
    pdf.set_font("Arial", size=12)
    pdf.ln(5)
    pdf.cell(0, 10, f"User: {user_email}", ln=True)
    pdf.ln(5)
    
    pdf.cell(0, 10, "Logged Sugar Levels:", ln=True)
    pdf.set_font("Arial", size=10)
    for entry in sugar_log:
        timestamp = entry['timestamp']
        if isinstance(timestamp, str):
            timestamp = datetime.fromisoformat(timestamp)
        entry_text = f"{timestamp.strftime('%Y-%m-%d %H:%M:%S')} - {entry['type']} - {entry['sugar_level']} mg/dL"
        try:
            pdf.cell(0, 8, entry_text, ln=True)
        except UnicodeEncodeError:
            pdf.cell(0, 8, entry_text.encode('latin-1', 'replace').decode('latin-1'), ln=True)
    
    pdf.ln(10)
    pdf.set_font("Arial", size=12)
    pdf.cell(0, 10, "Recommendations:", ln=True)
    pdf.set_font("Arial", size=10)
    pdf.multi_cell(0, 8, recommendations.encode('latin-1', 'replace').decode('latin-1'))
    
    pdf_output = BytesIO()
    pdf_output.write(pdf.output(dest='S').encode('latin-1'))
    pdf_output.seek(0)
    return pdf_output

def get_current_user():
    """Get current user email from session state."""
    user = st.session_state.get('current_user')
    if not user or not user.get('email'):
        st.error("User email not found. Please log in again.")
        st.stop()
    return user['email']

def get_user_history(user_email):
    """Fetch prediction history from Supabase."""
    try:
        response = (
            supabase.table("predictions")
            .select("*")
            .eq("user_email", user_email)
            .order("timestamp", desc=True)
            .execute()
        )
        return response.data or []
    except Exception as e:
        st.error(f"Failed to load history: {e}")
        return []

def initialize_user_session(user_email):
    """Initialize session state for user-specific data."""
    user_sugar_log_key = f"sugar_log_{user_email}"
    if user_sugar_log_key not in st.session_state:
        st.session_state[user_sugar_log_key] = load_sugar_log(user_email)

def app():
    current_user = get_current_user()
    initialize_user_session(current_user)
    
    user_sugar_log_key = f"sugar_log_{current_user}"
    
    user_profile = get_user_by_email(current_user) or {}
    meal_data = load_meal_log(current_user)
    history_data = get_user_history(current_user)
    
    st.markdown(st_style, unsafe_allow_html=True)
    st.markdown(head, unsafe_allow_html=True)
    
    st.title("ü©∫ Blood Sugar Tracker")
    
    st.sidebar.markdown(f"**üë§ Logged in as:** {current_user}")
    st.sidebar.markdown("---")
    
    st.subheader("üìù Log Blood Sugar Level")
    
    col1, col2 = st.columns([2, 1])
    with col1:
        sugar_level = st.number_input("Blood Sugar Level (mg/dL)", min_value=0, max_value=600, step=1)
    with col2:
        sugar_type = st.selectbox("Type", ["Fasting", "Post-Meal", "Random"])
    
    if st.button("Log Sugar Level"):
        if sugar_level > 0:
            st.session_state[user_sugar_log_key].append({
                "timestamp": datetime.now(IST),
                "sugar_level": sugar_level,
                "type": sugar_type
            })
            save_sugar_log(st.session_state[user_sugar_log_key], current_user)
            st.success(f"Logged {sugar_level} mg/dL ({sugar_type}).")
        else:
            st.error("Please enter a valid sugar level.")
    
    if st.button("Clear All Logged Sugar Levels"):
        st.session_state[user_sugar_log_key] = []
        save_sugar_log(st.session_state[user_sugar_log_key], current_user)
        st.success("All logged sugar levels cleared.")
    
    st.markdown("### üìÖ Calendar View")
    selected_date = st.date_input("Select a date to view logged sugar levels", value=date.today())
    
    if st.session_state[user_sugar_log_key]:
        df = pd.DataFrame(st.session_state[user_sugar_log_key])
        df['timestamp'] = pd.to_datetime(df['timestamp'])
        # Fix for Calendar View: Normalize timestamps to date in IST
        df_selected_date = df[df['timestamp'].dt.date == selected_date]
        
        if df_selected_date.empty:
            st.info(f"No sugar levels logged for {selected_date.strftime('%Y-%m-%d')}.")
        else:
            st.subheader(f"Sugar Levels for {selected_date.strftime('%Y-%m-%d')}")
            for i, row in df_selected_date.sort_values("timestamp", ascending=False).iterrows():
                cols = st.columns([2, 2, 2, 1])
                with cols[0]:
                    st.write(row["timestamp"].strftime("%Y-%m-%d %H:%M:%S"))
                with cols[1]:
                    st.write(row["type"])
                with cols[2]:
                    st.write(f"{row['sugar_level']} mg/dL")
                with cols[3]:
                    if st.button("Clear This", key=f"clear_{i}"):
                        st.session_state[user_sugar_log_key] = [entry for j, entry in enumerate(st.session_state[user_sugar_log_key]) if j != i]
                        save_sugar_log(st.session_state[user_sugar_log_key], current_user)
                        st.success(f"Removed {row['sugar_level']} mg/dL from log.")
                        st.rerun()
    
    st.markdown("### üìä Current Status")
    if st.session_state[user_sugar_log_key]:
        df = pd.DataFrame(st.session_state[user_sugar_log_key])
        df['timestamp'] = pd.to_datetime(df['timestamp'])
        if df['timestamp'].dt.tz is None:
            df['timestamp'] = df['timestamp'].dt.tz_localize(IST, errors='coerce')
        else:
            df['timestamp'] = df['timestamp'].dt.tz_convert(IST)
        
        today_ist = datetime.now(IST).date()
        df_today = df[df['timestamp'].dt.date == today_ist]
        
        if df_today.empty:
            st.info("No sugar levels logged for today.")
        else:
            st.subheader("Today's Logged Sugar Levels")
            for i, row in df_today.sort_values("timestamp", ascending=False).iterrows():
                cols = st.columns([2, 2, 2, 1])
                with cols[0]:
                    st.write(row["timestamp"].strftime("%Y-%m-%d %H:%M:%S"))
                with cols[1]:
                    st.write(row["type"])
                with cols[2]:
                    st.write(f"{row['sugar_level']} mg/dL")
                with cols[3]:
                    if st.button("Clear", key=f"clear_today_{i}"):
                        st.session_state[user_sugar_log_key] = [entry for j, entry in enumerate(st.session_state[user_sugar_log_key]) if j != i]
                        save_sugar_log(st.session_state[user_sugar_log_key], current_user)
                        st.success(f"Removed {row['sugar_level']} mg/dL from log.")
                        st.rerun()
            
            avg_sugar = df_today["sugar_level"].mean()
            st.metric("Average Sugar Level Today", f"{avg_sugar:.1f} mg/dL")
            
            fig, ax = plt.subplots()
            types = df_today["type"].unique()
            for t in types:
                df_type = df_today[df_today["type"] == t]
                ax.plot(df_type["timestamp"], df_type["sugar_level"], marker='o', label=t)
            ax.set_title("Today's Sugar Levels")
            ax.set_ylabel("Sugar Level (mg/dL)")
            ax.set_xlabel("Time")
            ax.legend()
            st.pyplot(fig)
    
    st.markdown("### üìà Weekly Trend")
    if st.session_state[user_sugar_log_key]:
        df = pd.DataFrame(st.session_state[user_sugar_log_key])
        df['timestamp'] = pd.to_datetime(df['timestamp'])
        if df['timestamp'].dt.tz is None:
            df['timestamp'] = df['timestamp'].dt.tz_localize(IST, errors='coerce')
        else:
            df['timestamp'] = df['timestamp'].dt.tz_convert(IST)
        
        today = datetime.now(IST).date()
        past_week = [today - timedelta(days=i) for i in range(6, -1, -1)]
        df['date_only'] = df['timestamp'].dt.date
        weekly_sugar = df.groupby('date_only')['sugar_level'].mean()
        weekly_sugar = weekly_sugar.reindex(past_week, fill_value=0)
        
        fig, ax = plt.subplots()
        ax.plot(past_week, weekly_sugar.values, marker='o', linestyle='-', color='#ff7f0e')
        ax.set_title("Average Sugar Levels Over Past 7 Days")
        ax.set_ylabel("Sugar Level (mg/dL)")
        ax.set_xlabel("Date")
        ax.set_xticks(past_week)
        ax.set_xticklabels([d.strftime("%a %d") for d in past_week], rotation=45)
        ax.axhline(100, color='green', linestyle='--', label='Target (e.g., 100 mg/dL)')
        ax.legend()
        st.pyplot(fig)
    
    st.markdown("### ü©∫ Personalized Recommendations")
    recommendations = get_ai_recommendations(
        st.session_state[user_sugar_log_key], meal_data, user_profile, history_data
    )
    st.markdown(recommendations)
    
    if st.button("Download Daily Report PDF"):
        pdf_bytes = generate_pdf_report(st.session_state[user_sugar_log_key], recommendations, current_user)
        st.download_button(
            label="Download PDF",
            data=pdf_bytes,
            file_name=f"sugar_report_{current_user.replace('@', '_')}_{date.today()}.pdf",
            mime="application/pdf"
        )
    
    st.markdown("### üîç Debug Options")
    if st.checkbox("Show Raw Sugar Log for Debugging"):
        st.write(st.session_state[user_sugar_log_key])

if __name__ == "__main__":
    app()
